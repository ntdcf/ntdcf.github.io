(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-273e4fc9"],{"02a9":function(t,e){t.exports="data:image/webp;base64,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"},"04d1":function(t,e,n){var o=n("342f"),r=o.match(/firefox\/(\d+)/i);t.exports=!!r&&+r[1]},"09b8":function(t,e,n){var o=n("4719"),r=n("02a9"),c=o(r),l='<p>在 React 前端项目中，可以使用路由来对各个页面进行跳转 url 的控制。React 路由可以使用 react-router-dom 包。通过 Router 声明路由。</p> <pre><code class="language-jsx">import React, { Component } from &#39;react&#39;\nimport { BrowserRouter as Router, Route, Switch } from &#39;react-router-dom&#39;\nimport Inbox from &#39;../view/inbox&#39;\nclass LinkRouter extends Component {\n    constructor(pros) {\n        super(pros)\n    }\n    render() {\n        return (\n            &lt;Router&gt;\n                &lt;Switch&gt;\n                    &lt;Route path=&quot;/inbox&quot; component={Inbox}/&gt;\n                &lt;/Switch&gt;\n            &lt;/Router&gt;\n        )\n    }\n}\nexport default LinkRouter</code></pre> <p>这样，在项目中就有了一个能跳转到 inbox 页面的路由，只要在地址栏中输入 <a href="http://localhost:3000/inbox">http://localhost:3000/inbox</a> 就可以看到 inbox 的内容。</p> <p><img src="'+c+'" alt=""></p> <p>接下来就需要使用这个路由了，在 React 中需要使用 Link 标签来使用路由，进行跳转，而 Link 标签是要和Route 标签是同一级的。</p> <pre><code class="language-jsx">class LinkRouter extends Component {\n    constructor(pros) {\n        super(pros)\n    }\n    render() {\n        return (\n            &lt;div&gt;\n                &lt;Router&gt;\n                    &lt;Switch&gt;\n                        &lt;Route path=&quot;/inbox&quot; component={Inbox}/&gt;  \n                        &lt;Link to=&quot;/inbox&quot;&gt;inbox&lt;/Link&gt; \n                    &lt;/Switch&gt;\n                &lt;/Router&gt;\n            &lt;/div&gt;\n        )\n    }\n}\nexport default LinkRouter</code></pre> <p>这样就能看到 inbox 这个字符编程超链接了，我们可以在浏览器中看到，Link 标签实际上是将自己本身编译成了 a 标签去使用的。点击超链接就能发现页面跳转到了inbox的页面。 因为 Link 必须和 Route 同级或者 Switch 下级的，这就意味着项目的根标签——通常是 <App/> 是被嵌套在这个路由中的，这样才能直接在项目的其他组件页面中使用 Link 标签 。</p> <pre><code>ReactDOM.render(\n    &lt;Router&gt;\n        &lt;Switch&gt;\n            &lt;Route path=&quot;/inbox&quot; component={Inbox}/&gt;  \n            &lt;Link to=&quot;/inbox&quot;&gt;inbox&lt;/Link&gt; \n        &lt;/Switch&gt;\n    &lt;/Router&gt;,\n    document.getElementById(&#39;root&#39;)\n);</code></pre><p>这样就会在项目入口文件中，混入很多代码，所以可以对这个路由进行一个封装。将项目的根标签通过参数传入，并且放在和 Route 同级或者 Switch 下级的地方。</p> <pre><code class="language-jsx">class LinkRouter extends Component {\n    constructor(pros) {\n        super(pros)\n    }\n    render() {\n        return (\n            &lt;div&gt;\n                &lt;Router&gt;\n                    &lt;Switch&gt;\n                        &lt;Route path=&quot;/inbox&quot; component={Inbox}/&gt;\n                        {this.props.app}  \n                    &lt;/Switch&gt;\n                &lt;/Router&gt;    \n            &lt;/div&gt;\n        )\n    }\n}\nexport default LinkRouter</code></pre> <p>修改后的入口文件可以这样写：</p> <pre><code class="language-jsx">import React from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\nimport App from &#39;./App&#39;;\nimport LinkRouter from &#39;./routers&#39;\n\nReactDOM.render(\n    &lt;LinkRouter app={&lt;App/&gt;} /&gt;,\n    document.getElementById(&#39;root&#39;)\n);</code></pre> <p>这样就构建了一个路由组件，在这个组件中可以放入所有的路由。在项目中，就直接使用 Link 标签进行路由的跳转就可以了。</p> ';t.exports=l},1766:function(t,e){var n='<p>很长时间没有看过数据结构了，二叉树都淡忘了，赶紧复习一下。</p> <p>二叉树是每个结点最多有两个子树的树结构。下面就定义一下如下：</p> <pre><code class="language-c">struct tree\n{\n    int data;\n    struct tree *child_l;\n    struct tree *child_r;\n};</code></pre> <p>关于二叉树，有多种遍历方式，前序，中序和后序，前中后代表了根节点的顺序，就是先根，中根，后根。</p> <p>遍历分为递归遍历和非递归遍历。</p> <p>递归遍历的代码非常简单。一下就是以前序为例子，进行前序遍历：</p> <pre><code class="language-c">void read_tree(struct tree *t) {\n    printf(&quot;%d\\n&quot;,t-&gt;data);\n    if (t-&gt;child_l != NULL)\n        read_tree(t-&gt;child_l);\n    if (t-&gt;child_r != NULL)\n        read_tree(t-&gt;child_r);\n}</code></pre> <p>非递归需要借助栈的数据结构，那么首先建立一个栈：</p> <pre><code class="language-c">struct stack {\n    struct tree* stack_value[10];\n    int top;\n};</code></pre> <p>并且初始化一个栈：</p> <pre><code class="language-c">#define NOMAL_COUNT 1\n\nstruct stack* init_stack() {\n    struct stack *s = (struct stack *) calloc(NOMAL_COUNT, sizeof(struct stack));\n    s-&gt;top = -1;\n    return s;\n}</code></pre> <p>然后是入栈和出栈：</p> <pre><code class="language-c"> void stack_push(struct stack *s, struct tree *t) {\n     s-&gt;top++;\n     s-&gt;stack_value[s-&gt;top] = t;\n}\n\nstruct tree* stack_pop(struct stack *s) {\n    struct tree *t = s-&gt;stack_value[s-&gt;top];\n    s-&gt;top--;\n    return t;\n}</code></pre> <p>接下来就是非递归遍历，非递归就是根完了一直向左，左边完全完了再访问右边：</p> <pre><code class="language-c">void read_tree2(struct tree *t) {\n    struct tree * temp = t;\n    struct stack *s = init_stack();\n\n    while (temp != NULL || s-&gt;top != -1) {\n        while (temp != NULL) {\n            printf(&quot;%d\\n&quot;, temp-&gt;data);\n            stack_push(s, temp);\n            temp = temp-&gt;child_l;\n        }\n        if (s-&gt;top != -1) {\n            temp = stack_pop(s); \n            temp = temp-&gt;child_r;\n        }\n    }\n}</code></pre> <p>初始化一下这个树：</p> <pre><code class="language-c">struct tree *t = (struct tree *) calloc(NOMAL_COUNT, sizeof(struct tree));\nstruct tree *temp;\nt-&gt;data = 1;\nt-&gt;child_l = (struct tree *) calloc(NOMAL_COUNT, sizeof(struct tree));\ntemp = t-&gt;child_l;\ntemp-&gt;data = 2;\ntemp-&gt;child_l = (struct tree *) calloc(NOMAL_COUNT, sizeof(struct tree));\ntemp-&gt;child_l-&gt;data = 4;\ntemp-&gt;child_r = (struct tree *) calloc(NOMAL_COUNT, sizeof(struct tree));\ntemp-&gt;child_r-&gt;data = 5;\nt-&gt;child_r = (struct tree *) calloc(NOMAL_COUNT, sizeof(struct tree));\nt-&gt;child_r-&gt;data = 3;</code></pre> <p>然后开始遍历就好啦，得到：1，2，4，5，3.</p> <p>接下来是二叉树排序：</p> <p>可以将小的放在左孩子上，大的放在右孩子上：</p> <pre><code class="language-c">void add_tree(struct tree *t, int number) {\n    if (t-&gt;data &gt; number) {\n        if (t-&gt;child_l != NULL) {\n            add_tree(t-&gt;child_l, number);\n        } else {\n            t-&gt;child_l = (struct tree *) calloc(NOMAL_COUNT, sizeof(struct tree));\n            t-&gt;child_l-&gt;data = number;\n        }\n    } else {\n        if (t-&gt;child_r != NULL) {\n            add_tree(t-&gt;child_r, number);\n        } else {\n            t-&gt;child_r = (struct tree *) calloc(NOMAL_COUNT, sizeof(struct tree));\n            t-&gt;child_r-&gt;data = number;\n        }\n    }\n}</code></pre> <p>然后就可以中序遍历二叉树，输出排序结果了：</p> <pre><code class="language-c">1 // 中序遍历二叉树\n2 void read_tree(struct tree *t) {\n3     if (t-&gt;child_l != NULL)\n4         read_tree(t-&gt;child_l);\n5     printf(&quot;%d\\n&quot;,t-&gt;data);\n6     if (t-&gt;child_r != NULL)\n7         read_tree(t-&gt;child_r);\n8 }</code></pre> <p>我们来测试一下：</p> <pre><code class="language-c"> 1 int main(int argc, char const *argv[])\n 2 {\n 3     int numbers[] = {8, 7, 1, 4, 3, 5, 9, 19, 13, 11, 15, 20, 16, 2, 6};\n 4     struct tree *t = (struct tree *) calloc(NOMAL_COUNT, sizeof(struct tree));\n 5     t-&gt;data = numbers[0];\n 6     for (int i = 1; i &lt; 15; i++) {\n 7         add_tree(t, numbers[i]);\n 8     }\n 9     read_tree(t);\n10     return 0;\n11 }</code></pre> <p>输出结果：</p> <pre><code class="language-bash">1\n2\n3\n4\n5\n6\n7\n8\n9\n11\n13\n15\n16\n19\n20</code></pre> ';t.exports=n},4719:function(t,e,n){"use strict";t.exports=function(t,e){return e||(e={}),t=t&&t.__esModule?t.default:t,"string"!==typeof t?t:(e.hash&&(t+=e.hash),e.maybeNeedQuotes&&/[\t\n\f\r "'=<>`]/.test(t)?'"'.concat(t,'"'):t)}},"4dae":function(t,e,n){var o=n("da84"),r=n("23cb"),c=n("07fa"),l=n("8418"),a=o.Array,p=Math.max;t.exports=function(t,e,n){for(var o=c(t),s=r(e,o),d=r(void 0===n?o:n,o),u=a(p(d-s,0)),i=0;s<d;s++,i++)l(u,i,t[s]);return u.length=i,u}},"4e82":function(t,e,n){"use strict";var o=n("23e7"),r=n("e330"),c=n("59ed"),l=n("7b0b"),a=n("07fa"),p=n("577e"),s=n("d039"),d=n("addb"),u=n("a640"),i=n("04d1"),g=n("d998"),h=n("2d00"),f=n("512c"),v=[],m=r(v.sort),x=r(v.push),A=s((function(){v.sort(void 0)})),R=s((function(){v.sort(null)})),b=u("sort"),k=!s((function(){if(h)return h<70;if(!(i&&i>3)){if(g)return!0;if(f)return f<603;var t,e,n,o,r="";for(t=65;t<76;t++){switch(e=String.fromCharCode(t),t){case 66:case 69:case 70:case 72:n=3;break;case 68:case 71:n=4;break;default:n=2}for(o=0;o<47;o++)v.push({k:e+o,v:n})}for(v.sort((function(t,e){return e.v-t.v})),o=0;o<v.length;o++)e=v[o].k.charAt(0),r.charAt(r.length-1)!==e&&(r+=e);return"DGBEFHACIJK"!==r}})),S=A||!R||!b||!k,q=function(t){return function(e,n){return void 0===n?-1:void 0===e?1:void 0!==t?+t(e,n)||0:p(e)>p(n)?1:-1}};o({target:"Array",proto:!0,forced:S},{sort:function(t){void 0!==t&&c(t);var e=l(this);if(k)return void 0===t?m(e):m(e,t);var n,o,r=[],p=a(e);for(o=0;o<p;o++)o in e&&x(r,e[o]);d(r,q(t)),n=r.length,o=0;while(o<n)e[o]=r[o++];while(o<p)delete e[o++];return e}})},"512c":function(t,e,n){var o=n("342f"),r=o.match(/AppleWebKit\/(\d+)\./);t.exports=!!r&&+r[1]},"5fe7":function(t,e){var n='<p>说道go语言web编程，必不可少的会使用到net/http包。go语言将web开发需要使用到的很多内容都放在了标准库中——net/http。</p> <p>如何写一个简单的web程序很容易。如下：</p> <pre><code class="language-golang">package main\n\nimport (\n    &quot;fmt&quot;\n    &quot;net/http&quot;\n)\n\nfunc hello(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, &quot;hello&quot;)\n}\n\nfunc main() {\n    server := &amp;http.Server{\n        Addr: &quot;0.0.0.0:8080&quot;,\n    }\n    http.HandleFunc(&quot;/hello&quot;, hello)\n    server.ListenAndServe()\n}</code></pre> <p>其中使用了http包。使用http.HandleFunc就是使用了一个处理器函数</p> <p>处理器函数是一个签名和ServeHTTP方法相同的函数，Go语言中，有一种HandlerFunc函数类型，可以加将这个函数转化为带有方法的处理器（Handler）？</p> <p>ServerMux是一个路由管理器，也可以说是一个多路复用器，使用方式如下：</p> <pre><code class="language-golang">package main\nimport (\n    &quot;fmt&quot;\n    &quot;net/http&quot;\n)\nfunc main() {\n    servermux := http.NewServeMux()\n    servermux.HandleFunc(&quot;/hello&quot;, hello)\n    server := &amp;http.Server{\n        Addr: &quot;:8080&quot;,\n        Handler: servermux,\n    }\n    server.ListenAndServe()\n}\nfunc hello(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintln(w, &quot;hello world&quot;)\n}</code></pre> <p>其实是在使用http.HandleFunc的时候，调用了</p> <pre><code class="language-golang">func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    DefaultServeMux.HandleFunc(pattern, handler)\n}</code></pre> <p>这样的话，其实是使用了一个变量DefaultServeMux，再看看这个变量的内容：</p> <pre><code class="language-golang">var DefaultServeMux = &amp;defaultServeMux\nvar defaultServeMux ServeMux</code></pre> <p>这个变量其实就是ServeMux的实例。也就是ServeMux，所以在使用http的handerfunc的时候，是使用了这个多路复用器的。这个处理器也是默认的处理器。如果没有声明或者直接使用其他的处理器的时候，调用处理器函数和处理器都是使用了这个。</p> <p>接下来看HandleFunc这个函数，以上使用的http包的函数HandleFunc最终调用的是ServeMux的HandleFunc。所以在使用的时候Handle和HandleFunc完全一致。</p> <p>type HandlerFunc func(ResponseWriter, *Request) HandleFunc最终会将函数转成HandleFunc，等同于Handler，Handler是一个接口，如下：</p> <pre><code class="language-golang">type Handler interface {\n    ServeHTTP(ResponseWriter, *Request)\n}</code></pre> <p>所以其实这两种类型是等价的。</p> ';t.exports=n},"78fe":function(t,e){var n='<p>和 Vue 的思想不同，在 React 中的变量并不是所有的都是在实时变化中的，所以需要状态 State 去维护需要刷新和变化的变量，当需要更新组件中的某个变量值的时候，需要更新组件的 state —— 当然这个变量也需要在 state 中，这样更新了 state 后， React 会根据新的 state 重新渲染页面。</p> <p>而 state 也是 React.Component 这个类中的成员变量，具体的定义可以参考 React 的源代码：</p> <pre><code class="language-javascript"> state: Readonly&lt;S&gt;;</code></pre> <p>需要更新的变量只要声明在构造函数的 state 中就可以通过 state 控制这些变量的更新：</p> <pre><code class="language-jsx">class Hello extends React.Component {\n    constructor() {\n        super()\n        this.state = {\n            clickText: &quot;&quot;\n        }\n    }\n    render() {\n        return (\n            &lt;div&gt;\n                &lt;h1&gt;hello world&lt;/h1&gt;\n                &lt;p&gt;{this.state.clickText}&lt;/p&gt;\n            &lt;/div&gt;\n        )\n    }\n}</code></pre> <p>接下来可以加一个按钮，当按钮点击的时候，显示出 click 的字样。这个时候，就需要对state进行操作，更新 state 操作使用 Component 这个父类的 setState 方法，这个方法是这样声明的</p> <pre><code class="language-javascript">setState&lt;K extends keyof S&gt;(\n   state: ((prevState: Readonly&lt;S&gt;, props: Readonly&lt;P&gt;) =&gt; (Pick&lt;S, K&gt; | S | null)) | (Pick&lt;S, K&gt; | S | null),\n   callback?: () =&gt; void\n): void;</code></pre> <p>所以可以当触发点击事件的时候，调用这个函数，是 state 发生变化，这样就能看到对应的地方先输出发生变化后的内容了。</p> <pre><code class="language-javascript">class Hello extends React.Component {\n    constructor() {\n        super()\n        this.state = {\n            clickText: &quot;&quot;\n        }\n    }\n    render() {\n        return (\n            &lt;div&gt;\n                &lt;h1&gt;hello world&lt;/h1&gt;\n                &lt;p&gt;{this.state.clickText}&lt;/p&gt;\n                &lt;button \n                    onClick={()=&gt; {\n                        this.setState({\n                            clickText: &quot;this is click&quot;\n                        })\n                    }}\n                &gt;click&lt;/button&gt;\n            &lt;/div&gt;\n        )\n    }\n}</code></pre> <p>当点击按钮的时候，会触发 setState 函数，将 state 中的 clickText 的内容赋值为 &quot;this is click&quot; ，然后 React 会因为 state 发生了更新，重新渲染页面，将新的值展示出来。 可以做一个对比，如果这个变量不是 state 的且不使用 setState 方法，React 会重新渲染页面吗？</p> <pre><code class="language-javascript">class Hello extends React.Component {\n    constructor() {\n        super()\n    }\n    outClickText = &quot;&quot;\n    render() {\n        return (\n            &lt;div&gt;\n                &lt;h1&gt;hello world&lt;/h1&gt;\n                &lt;p&gt;{this.state.clickText}&lt;/p&gt;\n                &lt;button \n                    onClick={()=&gt; {\n                        this.outClickText = &quot;this is click&quot;\n                        console.log(this.outClickText)\n                    }}\n                &gt;click&lt;/button&gt;\n            &lt;/div&gt;\n        )\n    }\n}</code></pre> <p>通过点击按钮，可以看到控制台输出的变量的值是 &quot;this is click&quot; ， 但是页面的显示的值并没有变化，这说明，如果该变量不是 state 中的，更新了，React 是不会重新渲染页面的。同样的，如果是 state 中的元素，只是单纯的赋值，没有使用 setState 方法更新，React 也不会更新状态，是不会进行渲染的。</p> <pre><code class="language-js">class Hello extends React.Component {\n    constructor() {\n        super()\n        this.state = {\n            clickText: &quot;&quot;\n        }\n    }\n    render() {\n        return (\n            &lt;div&gt;\n                &lt;h1&gt;hello world&lt;/h1&gt;\n                &lt;p&gt;{this.state.clickText}&lt;/p&gt;\n                &lt;button \n                    onClick={()=&gt; {\n                        this.state.clickText = &quot;this is click&quot;\n                        console.log(this.state.clickText)\n                    }}\n                &gt;click&lt;/button&gt;\n            &lt;/div&gt;\n        )\n    }\n}</code></pre> <p>这个时候，点击按钮，在控制台中可以看出，变量已经被赋值为 &quot;this is click&quot; ，但是因为没有使用 setState 更新，所以 React 并不会认为这是状态更新，也不会重新渲染页面，所以页面上还是没有出现新的变化。</p> ';t.exports=n},8418:function(t,e,n){"use strict";var o=n("a04b"),r=n("9bf2"),c=n("5c6c");t.exports=function(t,e,n){var l=o(e);l in t?r.f(t,l,c(0,n)):t[l]=n}},9679:function(t,e,n){t.exports=n.p+"img/58341172-71d9-11ec-af45-fa163e5f5043.b62da301.webp"},addb:function(t,e,n){var o=n("4dae"),r=Math.floor,c=function(t,e){var n=t.length,p=r(n/2);return n<8?l(t,e):a(t,c(o(t,0,p),e),c(o(t,p),e),e)},l=function(t,e){var n,o,r=t.length,c=1;while(c<r){o=c,n=t[c];while(o&&e(t[o-1],n)>0)t[o]=t[--o];o!==c++&&(t[o]=n)}return t},a=function(t,e,n,o){var r=e.length,c=n.length,l=0,a=0;while(l<r||a<c)t[l+a]=l<r&&a<c?o(e[l],n[a])<=0?e[l++]:n[a++]:l<r?e[l++]:n[a++];return t};t.exports=c},bc65:function(t,e){t.exports="data:image/webp;base64,UklGRlALAABXRUJQVlA4IEQLAAAwOQCdASoYAZoAPpFIn0ulpCKho1uIwLASCU3fj5M5HOaodEhV+JYQf6pOwfIEgN9Af/D9MboAc6B/pf1j9x/9p9QD+8f471dv8J///cK/pv+59gb+U/2j/6e01/4vYr/u//X9M31AP/f6gHUj9E/5R+F/s87xftP5J+cfjN9uZquW+0v+P/Yb8d+VXq3/jfC/1IeoF+N/yX/M7x2AD8u/pv+28Kb+v9Bfrh7AH8b/q3+U9Tf9V4U/oHsAfzH+y/8T+3+u//tf4jzufn/+Y/7/uF/zX+s/9f1zPZF+5fsn/tCJz5Z3yil7izt8QyAo/Y8kyeCiSDMGTk8Tn5z0FzIU/kM8rJUYpb1fIvgp6dUR4yLVyKED8IYbFrAX46/5dQyWGzqj06/tsGpGf6kUELAfOKCFFD8GLTbLpVn9LEwFcPyVOeYqBW3GRNVSjqm+5/3bAWca34YvVgXxKR2PLdwgdSjvcWsns8lAtAI8CKIcWd8ope4s75QkYiWSiFG4R76pDWxVlVjybZ77ylNb6KxXKfnYE1Tfby3+cuJc5HL0eNNCywTuDoyzYgBizvlFL/3JYcQUUvcWd8ope4s75RS9xZ3yil7izvlFL3FnfKKXuGgAAP7/x/AElRyQPyxV2xvJ7K+yTbeygBbQ6f85/MwAWzMfD/KY9d/to/S1t2kJTvnh2kTc0/nT2FlNAwJ6pm548bTehlpZLrrdh5gKTTpAmdWZUZ6TrKwdumAsxy4s5x5yhhDTEmyJS/y8WLsBrL69BM7dgRR6mumACsILb6np371G53E5scyccsC610X+48oQtBYcBKrM3Q2G4I9O4XWpd3Wkvu9ECiO7C67+yIDpvM7YkcPeEoqIRjwL9JuhYv6y+BmCSXGKe76iSTBV2jW+FfBkKetFVV6tErOJU/TNIr1Ga4J+C0w+bBge/nafwlKBcIBCfAMPflz2MW8VT8gf5gc01NQBx8jtJPYITb3V1vKbjC4kSqAHtN4nTkH1mb40P8EnYwzhgz0Up7SSan2n9LJ+jA+HrOT/9JdJkAGMNGK7LXq172kEK7nS5HHm0S7RNP5tmIpLAJ1qW+SIURiIAyfTAKZqy0eA1Ihd6JaeoSXPvmoe+88dU5QRFVw5KgblE2oHdA4P50jdlNJQ9qYvKzXYy2P3ZrPF4Ly6a38RiNT684pDwUiVmxRHuUl/gJ8shXYJpOKwYJzBb20zcWeaq7nEGEyaWMWbj4bBpd3uMFc3lXJOZXyKSeN3NLUryXQKWjIttUB6htT5tHbkSD/Q72ENYuBX7BiGM+gOd1A0XXB71yzI50jYLCP5WKMtzLYqJV4x7lvPyL8o4oI3gDpFidd17p+ieEc1mNHD2IosIGBdhTvAcb3VFsRkW6DIsxP20viTUCUjpgbT2pldQ1ucK7yBcM10ScWUbwCSIMa0mKJ6qhYvDhSeBavwOxmysJrCNvhBiqMnZVvCOmpghZXsLheIvx1bXISeRlby83o/Zd4Kn0Z4INkfGrooZL4dhQj9pYsoyTZkx52yTB97UFix6bUla+y7USWeuU+fraeDzl/f+pZK9dR6hwWVuZesAhXyaghxZ8M8vmXGmQ5ldXI02a4rMI3SzLm0kfgmSTQIj6HvJwxRe8FCIb1CuiSwPiEdlzENI1/7KAOzxo6nEFTkrQNeOKCFTtm5bt0jXJijK0rcRwpQBp9k8OvZ8QvOisa4/w2d1DSPevuzmbdZkeOun4+f18YL7dwM+9ZTm5gzKaSlmAAAO588fqAnm9/Ra2cUt5f7vnv51zm0Cy/KOR3qU+LkWGNw9Qy8S9WgtavrpIpHfvUrt2MJuhrTWrLtmSzAMRnjLF3E0aSJdZx9tvuKpaNx8v18v5MBFl3G7ZraiIQgH6rPTEfF+dlM2fmQR7lBlElvrfRIPu/bCxfxcgNWsW7BYdYy8lFJb9tALfYjZnhQKp5crYIIk1B0374jg5CakZTBks28pftb9XgNyhRJQqWZbVUfeTEXvSSRaVqdFDhw/bHV4yGFtjrFoZjBu1OVvoffOzwK1gRlkeqxzRwtRaW11WOSXoqsemDmkcfj5o+41fvYJR2wbJ0YzDUtJwVF5yfZPuHOXZMy6aq4YlY3F+LPqnGfva2pHL5pT5CquprmLYAM6qtPU/zeDVuxRvuJkboJp/Gn4t8uRmjiMKBOxBb7ChHoPOEA9QUcjKLlB1oItiFkjijJyc//D+SXNsfAPNCFyoPiEPZycXfP9v7upvo8Xs6arvstdIFGL1GIJPMpa4XcRFIx3tCROIbpjoky/dNvHOTpjpyrbWLdmS7bwa2xlilIotMog0ivk9M5T4Wh7CNVGqEgM/qlb70XCaVw/Yx8VvPQ9S+DBBW+ACxQRt8X07HDvAZrJuT9i4J3gHbx10ppKstoO+hBLTaZX3ykTku5LrQpp3/RVQHv84QKEp4fp+4mYP4NlaLGVbWlNECMO5nhUcLCbtzmkoAcpX4YRavZ5Hphj++XjeDnxIjQnJU2vN0LVOPFH7xcvFcoqazks1MqKMRRHEtt81OLi21zXGNEVKJYIuuXwoVpBA/nIqmS+Ee8vDoIWH7pyLRRKlCZfZ8806U0wwzmJ5LWjCN4BDhy71MImfmSUbNyLITam4MqsCnv5WC9xWkG+GRWT839suGHt9YRysZbRCAAAAA7ZuB+L29zdlzLJd26fYGqAvFYZZZw2t/ooPtnDtYuwNqun6yuOyLOZA4XsglPl6G1c/VS5ND8mgYdaqDyF95dWzVtEsRdyIGJI7vt21XhnX1lsXwGm/SUr2Z2nSJatVIpf0YHmQkTLlQJqnP7tXnYc+SJbQ0hFSQ5ZyUKk7vmZrO1Ggkkze7phHOhEw9u2wXLX2gwyv5YFGK+bpEvCP1oClUeR4RTImQuB7kH2kwa9SXsdRlv3UX49BJ9A5OOZod5WP2BHVmTFzi10vlGHE9lsRRP2ZKsS/9xk5ur92V7MLSlRVhjrvI0AiIpGi9VLgp2T+aXzZq6iMGTNBBlH98B0NryOwO+08br56YZ6pjsKPtTYvOb7YZphD+jV+dOF7XAJNycrn0JY/wJ05jd/lSE2IH1q3iVYzKVLF62mHlwCI26HJLFz5rAs4BRriYyTlnYxzTad3wG0tikPgO9LNFA1d4c5vbihBpMGIaKXIwsFvR8rXlVvOGzKV5bCcmZE+i7orqQQSIyK1xa4KP4uRj1iRqSPdfl4Z0p4sk+qUL33JLpSGQWvEG9RtjBN9DpZZjvMqVr0ViNG8z3j/KlJPsvMy1TNYk6+1I/9QFaV7km2LSEm5IhvWxRBbV3cGyPpHl7JRrBe37m5ZneDQm17cFKenIjCi0liZ3qhtlI0IT9gwp5geTUcWh0OFdZKmleTKB97eVfWFlazGFHuA4am/xsgFQYNI81oBp9JZTttnUvXa6ARdmuqBaUuvWAXOgalAUpSunm4pycotEgK9QPi44j57nr4MJCWzJUVkMi+QfZ4jDN/v/Fzb95aSIwremUBbZFt+7eRtNCtDs0kEQNS6Sxa+w676tf1IMpnhsx/lj83I2q6WzQOscrl/r0F8ghn+7TvdFZI/tDUdC9pqmUNaZLpRTzoJ32Lyq42Od8XUmGNY9n8GL7QxlIUJL7ilzWkfYQbO4apyM2zNknDI1SV/jBK7tl55JraZhcFxmOY5frKloYPuBE7l8mdjAiKoXU8Qmg38MAbUQcKxbzmBxg+R4rJf/DI9hGUhnk0X/4YBel5ynsfUL6STfQQZ0TY9lS5FOFRVSv6yk6v/e5ZdxdFN4YZu8e/LBpkn9zoFciyshlyqAmNQ4fAcTJLIKsTUfdNJzybxFFLLZC+QAAeuTyXgAAAAAA"},c298:function(t,e,n){var o=n("4719"),r=n("9679"),c=o(r),l='<p>React 的组件可以放入其他组件中去，有的时候，需要根据不同的调用显示不同的效果。这个时候，就需要向这个组件中传入参数。React 中提供了 <code>props</code> 可以传递参数。<code>props</code> 是传递进来的参数，是不可变得，在使用中，只能通过 <code>props</code> 的值去判断要显示什么样的结果，不能通过和用户交互。如果需要通过和用户的交互进行判断或者使用参数，则应该使用 state。 在 React 源码中，<code>prop</code>s 是这样定义的：</p> <pre><code class="language-javascript">readonly props: Readonly&lt;P&gt; &amp; Readonly&lt;{ children?: ReactNode }&gt;;</code></pre> <p>所以在组件中使用 props 变量也是 <code>Component</code> 父类中的变量。使用的时候是，<code>this.props</code> 的参数内容。比如想要定义一个参数名为text。使用的时候就是：<code>this.props.text</code>，下面的组件就使用 <code>text</code> 参数显示传入参数的内容：</p> <pre><code class="language-jsx">class Hello extends Component {\n    constructor(props) {\n        super(props)\n    }\n    render() {\n        return (\n            &lt;h1&gt;{this.props.text}&lt;/h1&gt;\n        )\n    }\n}</code></pre> <p>这样，在使用这个组件的时候，只要在标签中，给参数赋值就好了：</p> <pre><code class="language-jsx">class App extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;this is App&lt;/h1&gt;\n        &lt;Hello text= &quot;this is use props&quot; /&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n\nexport default App;</code></pre> <p>这样就可以在页面上看到下面的部分，是 <code>h1</code> 标签中传入的变量值。效果如下：</p> <p><img src="'+c+'" alt=""></p> ';t.exports=l},d998:function(t,e,n){var o=n("342f");t.exports=/MSIE|Trident/.test(o)},ee45:function(t,e,n){var o={"./0aa27d13-71d9-11ec-af45-fa163e5f5043.md":"c298","./25d7c54a-590d-4d03-ad24-83a63a7f35c5.md":"f2e3","./5df765b6-3eaf-464d-8d63-287cb9960f9b.md":"1766","./ad32a409-71d7-11ec-af45-fa163e5f5043.md":"09b8","./cd38a77e-cc9d-4c39-8fa8-198fac480ea4.md":"5fe7","./e0a52a8e-71ca-11ec-b4b2-acde48001122.md":"78fe"};function r(t){var e=c(t);return n(e)}function c(t){if(!n.o(o,t)){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}return o[t]}r.keys=function(){return Object.keys(o)},r.resolve=c,t.exports=r,r.id="ee45"},f2e3:function(t,e,n){var o=n("4719"),r=n("bc65"),c=o(r),l='<h2 id="使用-es6-类">使用 ES6 类</h2> <p>在 react 中可以使用传统的 js 语法，也可以使用 ES6 的类将松散的结构组件进行封装，这样可以项目组件化。每一个 react 的组件都是一个 React.Componet 的 ES6 类，所以需要继承 Component类 。例如，现在我们要写一个 Hello 的组件，使用这个组件输出一个 hello world 的标题。可以这样做：</p> <pre><code class="language-html">&lt;body&gt;\n    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n    &lt;script type=&quot;text/babel&quot;&gt;\n        class Hello extends React.Component {\n            render() {\n                return (\n                    &lt;div&gt;\n                        &lt;h1&gt;hello world&lt;/h1&gt;\n                    &lt;/div&gt;\n                )\n            }\n        }\n        ReactDOM.render(\n            &lt;div&gt;&lt;span&gt;test&lt;/span&gt;&lt;/div&gt;,\n            document.getElementById(&#39;example&#39;)\n        );\n    &lt;/script&gt;\n&lt;/body&gt;</code></pre> <p>这样如果要使用这个组件直接在需要的地方写上这个类的标签就好：</p> <pre><code class="language-javascript">ReactDOM.render(\n    &lt;div&gt;\n        &lt;span&gt;test&lt;/span&gt;\n        &lt;Hello /&gt;\n    &lt;/div&gt;,\n    document.getElementById(&#39;example&#39;)\n);</code></pre> <p>在使用这个标签的时候，很多时候，需要根据很多情况给这个标签传一些参数，让这个标签可以根据传递的参数进行一些判断或者输出。 这个时候需要使用 props 这个变量。在类中使用这个变量相当于使用父类的这个变量，具体可以看到 React 源码中的这条语句:</p> <pre><code class="language-javascript">readonly props: Readonly&lt;P&gt; &amp; Readonly&lt;{ children?: ReactNode }&gt;;</code></pre> <p>所以在使用的时候，应该这样写: this.props</p> <pre><code class="language-javascript">class Hello extends React.Component {\n    render() {\n        return (\n            &lt;div&gt;\n                &lt;h1&gt;hello world&lt;/h1&gt;\n                &lt;p&gt;{this.props.text}&lt;/p&gt;\n            &lt;/div&gt;\n        )\n    }\n}</code></pre> <p>这样在标签中使用 text 这个属性的时候，就可以将 text 属性的内容显示在下面的 p 标签中了。</p> <pre><code class="language-javascript">ReactDOM.render(\n    &lt;div&gt;\n        &lt;span&gt;test&lt;/span&gt;\n        &lt;Hello text=&quot;this is test react&quot;/&gt;\n    &lt;/div&gt;,\n    document.getElementById(&#39;example&#39;)\n);</code></pre> <p>效果如下</p> <p><img src="'+c+'" alt=""></p> <h2 id="使用-jsx">使用 JSX</h2> <p>在react中，使用了JSX代替了传统的JavaScript。 怎么说 JSX 呢，JSX 就是 HTML 和 JS 和混合版，JSX 会将一个包裹好的 HTML 元素当做变量类型。</p> <pre><code class="language-jsx">const text = &lt;h1&gt;hello&lt;/h1&gt;</code></pre> <p>这样的标签语法就称为 JSX，这样的一个标签元素也可以做为 React 中的 ReactNode 类型。在 JSX 中可以使用 JS 的表达式。例如：</p> <pre><code class="language-jsx">const text = &lt;h1&gt;hello, {1+2}&lt;/h1&gt;</code></pre> <p>这里的显示结果为 hello，3 。而 JAX 文件中不能使用 if else 语句，只能使用表达式，所以三元运算符是可以使用的。</p> <p>对于一个 JSX ，我们也可以将这个 JSX 写成在独立的 js 文件中，使用的时候引入。也可以在工程化组件化中，写成一个 .jsx 文件， import 后使用。</p> ';t.exports=l}}]);
//# sourceMappingURL=chunk-273e4fc9.838311f6.js.map